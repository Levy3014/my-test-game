<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Hex Conquest - Expanded with AI and Minimap Fix</title>
<style>
  /* Basic reset & layout */
  body {
    margin: 0; padding: 0; background: #222; color: white;
    font-family: Arial, sans-serif;
    user-select: none;
    display: flex;
    height: 100vh;
    overflow: hidden;
  }
  #container {
    flex: 1;
    display: flex;
    flex-direction: column;
    max-width: 1000px;
    margin: 0 auto;
    user-select: none;
    position: relative;
  }
  canvas#gameCanvas {
    background: #333;
    border-radius: 8px;
    border: 2px solid #555;
    flex: 1;
    display: block;
  }
  #sidebar {
    width: 320px;
    background: #111;
    padding: 20px;
    box-sizing: border-box;
    border-left: 2px solid #444;
    display: flex;
    flex-direction: column;
  }
  button {
    background: #3498db;
    border: none;
    padding: 10px 20px;
    margin: 8px 0;
    font-size: 16px;
    color: white;
    cursor: pointer;
    border-radius: 6px;
  }
  button:disabled {
    background: #555;
    cursor: not-allowed;
  }
  h2, h3 {
    margin: 10px 0 5px 0;
  }
  #tooltip {
    position: absolute;
    background: #222;
    color: #eee;
    border: 1px solid #555;
    padding: 6px 8px;
    border-radius: 4px;
    pointer-events: none;
    font-size: 14px;
    visibility: hidden;
    max-width: 220px;
    z-index: 10;
  }
  #playerInfo {
    margin-bottom: 10px;
  }
  .unit-icon {
    display: inline-block;
    width: 20px; height: 20px;
    margin-right: 5px;
    vertical-align: middle;
  }
  .unit-icon.soldier {
    background: url('https://img.icons8.com/ios-filled/50/ffffff/soldier-helmet.png') no-repeat center center;
    background-size: contain;
  }
  .unit-icon.fort {
    background: url('https://img.icons8.com/ios-filled/50/ffffff/castle.png') no-repeat center center;
    background-size: contain;
  }
  #phaseDisplay {
    margin-bottom: 15px;
    font-weight: bold;
    font-size: 18px;
  }
  #moneyDisplay {
    margin-bottom: 15px;
  }
  #shop {
    border-top: 1px solid #444;
    padding-top: 15px;
    flex-grow: 1;
  }
  #shop button {
    width: 100%;
  }

  /* Minimap styles */
  #minimapContainer {
    margin-top: 15px;
    background: #222;
    border: 1px solid #444;
    border-radius: 6px;
    padding: 6px;
  }
  #minimap {
    background: #111;
    display: block;
    width: 280px;
    height: 280px;
    border-radius: 4px;
  }

  /* Menu screen styles */
  #menuScreen {
    position: absolute;
    inset: 0;
    background: #111;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 50;
    color: white;
  }
  #menuScreen h1 {
    margin-bottom: 20px;
    font-size: 36px;
  }
  #playersContainer {
    width: 320px;
    max-width: 90vw;
    background: #222;
    padding: 20px;
    border-radius: 8px;
    box-sizing: border-box;
    margin-bottom: 20px;
  }
  .playerSlot {
    display: flex;
    align-items: center;
    margin-bottom: 12px;
  }
  .playerSlot label {
    flex: 0 0 70px;
  }
  .playerSlot input[type="text"] {
    flex: 1;
    padding: 6px 8px;
    font-size: 14px;
    border-radius: 4px;
    border: none;
    margin-right: 8px;
  }
  .playerSlot select {
    margin-left: 8px;
    padding: 6px;
    border-radius: 4px;
    font-size: 14px;
    background: #333;
    color: white;
    border: none;
    cursor: pointer;
  }
  .playerSlot button {
    margin-left: 8px;
    padding: 6px 12px;
    font-size: 14px;
  }
  #startGameBtn {
    background: #27ae60;
    font-size: 18px;
    padding: 12px 30px;
    border-radius: 8px;
  }

  /* Scrollbar hidden for minimap container */
  #minimapContainer::-webkit-scrollbar {
    display: none;
  }
  #minimapContainer {
    -ms-overflow-style: none;  /* IE and Edge */
    scrollbar-width: none;  /* Firefox */
  }
</style>
</head>
<body>

<div id="container">
  <canvas id="gameCanvas" width="900" height="800"></canvas>
  <div id="tooltip"></div>
</div>

<div id="sidebar">
  <div id="playerInfo"></div>
  <div id="moneyDisplay"></div>
  <div id="phaseDisplay"></div>
  
  <div id="shop">
    <h3>Shop</h3>
    <button id="buySoldier" disabled>Buy Soldier (10 Gold)</button>
    <button id="buildFort" disabled>Build Fort (20 Gold)</button>
  </div>

  <button id="endTurnBtn" disabled>End Turn</button>

  <div id="minimapContainer">
    <h3>Minimap</h3>
    <canvas id="minimap" width="280" height="280"></canvas>
  </div>
</div>

<!-- Menu Screen -->
<div id="menuScreen">
  <h1>Hex Conquest</h1>
  <div id="playersContainer">
    <!-- Player slots will be dynamically inserted here -->
  </div>
  <button id="startGameBtn" disabled>Start Game</button>
</div>

<script>
(() => {
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  const tooltip = document.getElementById('tooltip');
  const playerInfoDiv = document.getElementById('playerInfo');
  const moneyDisplay = document.getElementById('moneyDisplay');
  const phaseDisplay = document.getElementById('phaseDisplay');
  const buySoldierBtn = document.getElementById('buySoldier');
  const buildFortBtn = document.getElementById('buildFort');
  const endTurnBtn = document.getElementById('endTurnBtn');
  const minimapCanvas = document.getElementById('minimap');
  const minimapCtx = minimapCanvas.getContext('2d');

  const menuScreen = document.getElementById('menuScreen');
  const playersContainer = document.getElementById('playersContainer');
  const startGameBtn = document.getElementById('startGameBtn');

  // Constants for hex grid
  const hexSize = 30;
  const mapRadius = 7; // bigger map for minimap
  const mapBorderRadius = mapRadius + 1; // border limit for camera

  // Camera state
  let cameraOffset = {x: 0, y: 0};
  let cameraDragStart = null;
  let cameraZoom = 1;
  const cameraZoomMin = 0.7;
  const cameraZoomMax = 2.0;

  // Game State
  let players = [];
  let currentPlayerIndex = 0;

  const phases = ['Resource', 'Build', 'Move', 'Combat', 'Capture'];
  let currentPhaseIndex = 0;

  let hexMap = [];
  let selectedTile = null;

  // AI difficulties
  const aiDifficulties = ['Easy', 'Medium', 'Hard'];

  // Update label (top-left corner)
  let updateLabel = 'Added AI & Minimap Fix';

  // ----------- MENU LOGIC --------------

  // Player slot template
  /*
    Each player slot: 
    - Name input
    - Add Human button
    - Add AI button + AI difficulty dropdown (only if AI selected)
    - Remove button if slot is filled
  */

  let playerSlots = []; // {id, type:'human'|'ai'|null, name, aiDifficulty}

  function createPlayerSlot(id) {
    const slotDiv = document.createElement('div');
    slotDiv.className = 'playerSlot';
    slotDiv.dataset.id = id;

    const label = document.createElement('label');
    label.textContent = `Player ${id + 1}:`;
    slotDiv.appendChild(label);

    const nameInput = document.createElement('input');
    nameInput.type = 'text';
    nameInput.placeholder = 'Enter name';
    nameInput.value = `Player${id + 1}`;
    slotDiv.appendChild(nameInput);

    // Add Human Button
    const addHumanBtn = document.createElement('button');
    addHumanBtn.textContent = 'Add Human';
    slotDiv.appendChild(addHumanBtn);

    // Add AI Button
    const addAIBtn = document.createElement('button');
    addAIBtn.textContent = 'Add AI';
    slotDiv.appendChild(addAIBtn);

    // AI Difficulty dropdown (hidden by default)
    const aiDifficultySelect = document.createElement('select');
    aiDifficulties.forEach(d => {
      const option = document.createElement('option');
      option.value = d.toLowerCase();
      option.textContent = d;
      aiDifficultySelect.appendChild(option);
    });
    aiDifficultySelect.style.marginLeft = '8px';
    aiDifficultySelect.style.display = 'none';
    slotDiv.appendChild(aiDifficultySelect);

    // Remove Player Button (hidden initially)
    const removeBtn = document.createElement('button');
    removeBtn.textContent = 'Remove';
    removeBtn.style.marginLeft = '8px';
    removeBtn.style.backgroundColor = '#e74c3c';
    removeBtn.style.display = 'none';
    slotDiv.appendChild(removeBtn);

    // Slot state
    playerSlots[id] = {
      id,
      type: null,
      nameInput,
      addHumanBtn,
      addAIBtn,
      aiDifficultySelect,
      removeBtn,
      slotDiv
    };

    // Event listeners
    addHumanBtn.onclick = () => {
      playerSlots[id].type = 'human';
      playerSlots[id].name = nameInput.value.trim() || `Human${id+1}`;
      updateSlotUI(id);
      validateStart();
    };
    addAIBtn.onclick = () => {
      playerSlots[id].type = 'ai';
      playerSlots[id].name = `AI${id+1}`;
      playerSlots[id].aiDifficulty = aiDifficultySelect.value || 'easy';
      updateSlotUI(id);
      validateStart();
    };
    removeBtn.onclick = () => {
      playerSlots[id].type = null;
      playerSlots[id].name = '';
      updateSlotUI(id);
      validateStart();
    };
    aiDifficultySelect.onchange = () => {
      if(playerSlots[id].type === 'ai'){
        playerSlots[id].aiDifficulty = aiDifficultySelect.value;
      }
    };
    nameInput.oninput = () => {
      if(playerSlots[id].type === 'human') {
        playerSlots[id].name = nameInput.value.trim() || `Human${id+1}`;
      }
    };

    playersContainer.appendChild(slotDiv);
    updateSlotUI(id);
  }

  function updateSlotUI(id) {
    const slot = playerSlots[id];
    if(slot.type === 'human') {
      slot.nameInput.disabled = false;
      slot.addHumanBtn.style.display = 'none';
      slot.addAIBtn.style.display = 'none';
      slot.aiDifficultySelect.style.display = 'none';
      slot.removeBtn.style.display = 'inline-block';
    } else if(slot.type === 'ai') {
      slot.nameInput.value = slot.name || `AI${id+1}`;
      slot.nameInput.disabled = true;
      slot.addHumanBtn.style.display = 'none';
      slot.addAIBtn.style.display = 'none';
      slot.aiDifficultySelect.style.display = 'inline-block';
      slot.aiDifficultySelect.value = slot.aiDifficulty || 'easy';
      slot.removeBtn.style.display = 'inline-block';
    } else {
      // Empty slot
      slot.nameInput.disabled = false;
      slot.nameInput.value = '';
      slot.addHumanBtn.style.display = 'inline-block';
      slot.addAIBtn.style.display = 'inline-block';
      slot.aiDifficultySelect.style.display = 'none';
      slot.removeBtn.style.display = 'none';
    }
  }

  function validateStart() {
    // We require at least 1 player (human or AI) to start
    const validPlayers = playerSlots.filter(p => p.type !== null);
    startGameBtn.disabled = validPlayers.length === 0;
  }

  startGameBtn.onclick = () => {
    // Load players from slots
    players = [];
    playerSlots.forEach(slot => {
      if(slot.type !== null) {
        players.push({
          name: slot.name || (slot.type === 'ai' ? 'AI' : 'Human'),
          type: slot.type,
          aiDifficulty: slot.aiDifficulty || 'easy',
          money: 50,
          units: [],
          forts: [],
          id: slot.id,
          xp: 0,
          cosmeticsUnlocked: []
        });
      }
    });
    if(players.length === 0) return; // safety

    menuScreen.style.display = 'none';
    initGame();
  };

  // Initialize 4 player slots by default
  for(let i=0; i<4; i++) createPlayerSlot(i);
  // Default first slot as human with name Player1
  playerSlots[0].type = 'human';
  playerSlots[0].name = 'Player1';
  updateSlotUI(0);
  validateStart();

  // ----------- HEX MAP & GAME LOGIC -----------

  // Hex grid axial coordinate helpers
  function hexToPixel(q, r) {
    const x = hexSize * Math.sqrt(3) * (q + r/2);
    const y = hexSize * 1.5 * r;
    return {x, y};
  }
  function pixelToHex(x, y) {
    const q = (x * Math.sqrt(3)/3 - y/3) / hexSize;
    const r = y * 2/3 / hexSize;
    return hexRound(q, r);
  }
  function hexRound(q, r) {
    let x = q;
    let z = r;
    let y = -x - z;

    let rx = Math.round(x);
    let ry = Math.round(y);
    let rz = Math.round(z);

    const x_diff = Math.abs(rx - x);
    const y_diff = Math.abs(ry - y);
    const z_diff = Math.abs(rz - z);

    if(x_diff > y_diff && x_diff > z_diff) {
      rx = -ry - rz;
    } else if(y_diff > z_diff) {
      ry = -rx - rz;
    } else {
      rz = -rx - ry;
    }
    return {q: rx, r: rz};
  }

  // Generate hex map as a hexagon shaped grid
  function generateHexMap(radius) {
    const map = [];
    for(let q = -radius; q <= radius; q++) {
      const r1 = Math.max(-radius, -q - radius);
      const r2 = Math.min(radius, -q + radius);
      for(let r = r1; r <= r2; r++) {
        map.push({
          q, r,
          type: 'grass', // grass or mountain etc
          owner: null,
          unit: null,
          fort: false,
          x: 0, y: 0
        });
      }
    }
    return map;
  }

  // Find tile by axial q,r
  function findTile(q, r) {
    return hexMap.find(t => t.q === q && t.r === r);
  }

  // Check if tile is inside border (for camera limits)
  function isInMapBounds(q, r) {
    return Math.abs(q) <= mapBorderRadius && Math.abs(r) <= mapBorderRadius && Math.abs(q + r) <= mapBorderRadius;
  }

  // Set hexMap global
  hexMap = generateHexMap(mapRadius);
  hexMap.forEach(tile => {
    const pos = hexToPixel(tile.q, tile.r);
    tile.x = pos.x;
    tile.y = pos.y;
  });

  // --------- DRAWING -----------

  // Clear canvas & draw hex grid
  function drawHex(ctx, x, y, size, fillStyle, strokeStyle, lineWidth=2) {
    const angle_deg = 60;
    const angle_rad = Math.PI / 180 * angle_deg;
    ctx.beginPath();
    for(let i=0; i < 6; i++) {
      const px = x + size * Math.cos(angle_rad * i);
      const py = y + size * Math.sin(angle_rad * i);
      if(i === 0) ctx.moveTo(px, py);
      else ctx.lineTo(px, py);
    }
    ctx.closePath();
    if(fillStyle) {
      ctx.fillStyle = fillStyle;
      ctx.fill();
    }
    if(strokeStyle) {
      ctx.strokeStyle = strokeStyle;
      ctx.lineWidth = lineWidth;
      ctx.stroke();
    }
  }

  // Draw entire map with units, forts, owners
  function drawMap() {
    ctx.save();
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.translate(canvas.width/2 + cameraOffset.x, canvas.height/2 + cameraOffset.y);
    ctx.scale(cameraZoom, cameraZoom);

    // Draw tiles
    for(const tile of hexMap) {
      let fill = '#2c3e50'; // default grass dark
      if(tile.owner !== null) {
        fill = players[tile.owner].color || '#2980b9';
      }
      if(tile === selectedTile) fill = '#f39c12'; // highlight selected
      drawHex(ctx, tile.x, tile.y, hexSize - 2, fill, '#34495e', 2);

      // Forts
      if(tile.fort) {
        ctx.fillStyle = 'white';
        ctx.beginPath();
        ctx.arc(tile.x, tile.y, hexSize/3, 0, Math.PI * 2);
        ctx.fill();
      }
      // Units
      if(tile.unit) {
        ctx.fillStyle = tile.unit.owner === currentPlayerIndex ? '#2ecc71' : '#e74c3c';
        ctx.beginPath();
        ctx.arc(tile.x, tile.y, hexSize/4, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    ctx.restore();
  }

  // Draw minimap as simplified version
  function drawMinimap() {
    minimapCtx.clearRect(0, 0, minimapCanvas.width, minimapCanvas.height);
    const w = minimapCanvas.width;
    const h = minimapCanvas.height;

    // Draw tiles scaled down and colored by owner
    const scale = 10;
    const centerX = w / 2;
    const centerY = h / 2;

    for(const tile of hexMap) {
      const x = centerX + tile.q * scale * 0.87;
      const y = centerY + tile.r * scale * 1.5;
      minimapCtx.beginPath();
      minimapCtx.fillStyle = tile.owner !== null ? (players[tile.owner].color || '#2980b9') : '#2c3e50';
      minimapCtx.strokeStyle = '#222';
      minimapCtx.lineWidth = 1;
      const size = 6;
      for(let i=0; i<6; i++) {
        const angle = Math.PI / 180 * 60 * i;
        const px = x + size * Math.cos(angle);
        const py = y + size * Math.sin(angle);
        if(i === 0) minimapCtx.moveTo(px, py);
        else minimapCtx.lineTo(px, py);
      }
      minimapCtx.closePath();
      minimapCtx.fill();
      minimapCtx.stroke();
    }

    // Draw camera viewport rectangle on minimap
    const camX = -cameraOffset.x / cameraZoom / hexSize / Math.sqrt(3);
    const camY = -cameraOffset.y / cameraZoom / hexSize / 1.5;

    const viewW = canvas.width / cameraZoom / (hexSize * Math.sqrt(3)) * 0.87 * 10;
    const viewH = canvas.height / cameraZoom / (hexSize * 1.5) * 10;

    minimapCtx.strokeStyle = 'yellow';
    minimapCtx.lineWidth = 2;
    minimapCtx.strokeRect(
      centerX + camX * 10 * 0.87 - viewW/2,
      centerY + camY * 10 * 1.5 - viewH/2,
      viewW,
      viewH
    );
  }

  // --------- INPUT & INTERACTION ---------

  let mousePos = {x: 0, y: 0};
  let isDragging = false;

  canvas.addEventListener('mousedown', (e) => {
    isDragging = true;
    cameraDragStart = {x: e.clientX - cameraOffset.x, y: e.clientY - cameraOffset.y};
  });
  window.addEventListener('mouseup', () => {
    isDragging = false;
  });
  window.addEventListener('mousemove', (e) => {
    mousePos = {x: e.clientX, y: e.clientY};
    if(isDragging) {
      cameraOffset.x = e.clientX - cameraDragStart.x;
      cameraOffset.y = e.clientY - cameraDragStart.y;
      clampCamera();
    }
    updateTooltip();
  });
  canvas.addEventListener('click', (e) => {
    const rect = canvas.getBoundingClientRect();
    const cx = (e.clientX - rect.left - canvas.width/2 - cameraOffset.x) / cameraZoom;
    const cy = (e.clientY - rect.top - canvas.height/2 - cameraOffset.y) / cameraZoom;
    const hex = pixelToHex(cx, cy);

    const tile = findTile(hex.q, hex.r);
    if(tile) {
      selectedTile = tile;
      // Zoom in a bit when selecting
      cameraZoom = Math.min(cameraZoom + 0.3, cameraZoomMax);
      clampCamera();
      draw();
    }
  });

  canvas.addEventListener('wheel', (e) => {
    e.preventDefault();
    const zoomAmount = -e.deltaY * 0.0015;
    cameraZoom = Math.min(cameraZoomMax, Math.max(cameraZoomMin, cameraZoom + zoomAmount));
    clampCamera();
    draw();
  }, {passive: false});

  function clampCamera() {
    // Prevent infinite scroll outside map border
    const maxOffsetX = hexSize * Math.sqrt(3) * (mapBorderRadius + 1.5);
    const maxOffsetY = hexSize * 1.5 * (mapBorderRadius + 1.5);

    cameraOffset.x = Math.min(maxOffsetX, Math.max(-maxOffsetX, cameraOffset.x));
    cameraOffset.y = Math.min(maxOffsetY, Math.max(-maxOffsetY, cameraOffset.y));
  }

  function updateTooltip() {
    if(!selectedTile) {
      tooltip.style.display = 'none';
      return;
    }
    tooltip.style.display = 'block';
    tooltip.style.left = (mousePos.x + 10) + 'px';
    tooltip.style.top = (mousePos.y + 10) + 'px';

    let text = `Tile: (${selectedTile.q}, ${selectedTile.r})\nType: ${selectedTile.type}`;
    if(selectedTile.owner !== null) {
      text += `\nOwner: ${players[selectedTile.owner].name}`;
    }
    if(selectedTile.fort) {
      text += `\nFort: Yes`;
    }
    if(selectedTile.unit) {
      text += `\nUnit: Owned by ${players[selectedTile.unit.owner].name}`;
    }

    tooltip.textContent = text;
  }

  // --------- GAME LOOP ---------

  function gameLoop() {
    draw();
    drawMinimap();
    updateTooltip();
    requestAnimationFrame(gameLoop);
  }

  // --------- GAME INIT ---------

  function initGame() {
    currentPlayerIndex = 0;
    selectedTile = null;
    cameraOffset = {x: 0, y: 0};
    cameraZoom = 1;
    draw();
    drawMinimap();
    gameLoop();
  }

  // Initial draw on load
  draw();
  drawMinimap();
})();
</script>

</body>
</html>
